{"pages":[{"title":"404","text":"","path":"404/index.html","date":"08-16","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"08-16","excerpt":""}],"posts":[{"title":"设计模式","text":"定义 策略模式定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。 UML 策略模式实际上减少了算法与使用算法类之间的耦合，在接口中为Context定义一系列可供重用的方法，当需要拓展时，只需要实现这个接口。策略模式就是用于封装一系列的算法，但是在实践中，可以用来封装几乎任何的类型的规则，只要分析过程存在需要在不同时间应用不同的业务规则，就可以考虑使用策略模式。 基本策略模式public interface Strategy { //算法方法 void strategyInterface(); } public class ConcreteStrategyA implements Strategy{ @Override public void strategyInterface() { System.out.println(&quot;算法A&quot;); } } public class ConcreteStrategyA implements Strategy{ @Override public void strategyInterface() { System.out.println(&quot;算法A&quot;); } } public class ConcreteStrategyB implements Strategy { @Override public void strategyInterface() { System.out.println(&quot;算法B&quot;); } } public class ConcreteStrategyC implements Strategy{ @Override public void strategyInterface() { System.out.println(&quot;算法C&quot;); } } public class Context { Strategy strategy; public Context(Strategy strategy) { this.strategy = strategy; } //上下文接口 public void contextInterface(){ strategy.strategyInterface(); } } public class Main { public static void main(String[] args){ Context context = new Context(new ConcreteStrategyA()); context.contextInterface(); } } 但是在应用中，这种需要具体实现的策略的职责却全部由客户端对象来承担，之后在转交给策略模式的Context对象，这样并没有减轻客户端的压力。我们可以把策略模式与简单工厂模式相结合，在客户端对象提出需求，之后由Context中的构造方法中的简单工厂判断需要具体实现的算法。 修改构造方法public Context(String type){ switch (type){ case &quot;算法A&quot;: strategy = new ConcreteStrategyA(); break; case &quot;算法B&quot;: strategy = new ConcreteStrategyB(); break; case &quot;算法C&quot;: strategy = new ConcreteStrategyC(); break; } 但这样也只是一种折中的方法，但需要添加新的算法时，还需要修改Context，违反了开闭原则。对于这种，就可以舍去switch,使用反射机制，通过传入的字符串来获得所需要的对象。","path":"2018/08/17/设计模式之策略模式/","date":"08-17","excerpt":""},{"title":"从零开始的Java之旅（一）","text":"","path":"2018/08/17/从零开始的Java之旅（一）/","date":"08-17","excerpt":""}]}